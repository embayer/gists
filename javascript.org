* remove umlaute
#+BEGIN_SRC javascript
// used for sort
export function removeUmlauts (str) {
  return str
    .replace(/Ä/g, 'A')
    .replace(/ä/g, 'a')
    .replace(/Ö/g, 'O')
    .replace(/ö/g, 'o')
    .replace(/Ü/g, 'U')
    .replace(/ü/g, 'u')
    .replace(/ß/g, 'ss')
}
#+END_SRC

* unique hex colors for strings
#+BEGIN_SRC javascript
// helper function to generate hexcolors for strings
stringToColour: function (str) {
  // employee color
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash)
  }
  let colour = '#'
  for (let i = 0; i < 3; i++) {
    let value = (hash >> (i * 8)) & 0xFF
    colour += ('00' + value.toString(16)).substr(-2)
  }
  return colour
}
#+END_SRC

* drag and drop
https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API
** Firefox: dragevents only fire when `initialized`
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC
** IE: DataTransfer.setData() format param has to be 'text'
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC

* limit function calls
** throttle
Throttling enforces a maximum number of times a function can be called
over time.
*Execute this function at most once every 100 milliseconds.*
#+BEGIN_SRC javascript
  function throttle (func, limit) {
    let lastFunc
    let lastRan
    return function () {
      const context = this
      const args = arguments
      if (!lastRan) {
        func.apply(context, args)
        lastRan = Date.now()
      } else {
        clearTimeout(lastFunc)
        lastFunc = setTimeout(function() {
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args)
            lastRan = Date.now()
          }
        }, limit - (Date.now() - lastRan))
      }
    }
  }
#+END_SRC

** debounce
Debouncing enforces that a function not be called again until a
certain amount of time has passed without it being called.
*execute this function only if 100 milliseconds have passed without it being called.*
#+BEGIN_SRC javascript
  function debounce (func, delay) {
    let inDebounce
    return function () {
      const context = this
      const args = arguments
      clearTimeout(inDebounce)
      inDebounce = setTimeout(() =>
          func.apply(context, args)
        , delay)
    }
  }
#+END_SRC

** use in Vue
#+BEGIN_SRC javascript
...
drag: throttle(function (event) {
  // code
}, 100),
...

#+END_SRC


* Immediately-Invoked Function Expression (IIFE)
Maintain Readability for Conditional Assignments with JavaScript IIFEs
You can use Immediately Invoked Function Expressions (IIFE's) to make
conditional assignments more readable and robust

#+BEGIN_SRC javascript
const greeting = (() => {
  if (isJoiningRoom) return 'Welcome'
  if (isLeavingRoom) return 'Bye'
  if (isReEnteringRoom) return 'Welcome back'
  return 'Hi'
})()
#+END_SRC

* String

** replcae
replaces only the first occurrence when invoked with two strings
#+BEGIN_SRC javascript
'2018-10-22'.replace('-', '_')  // '2018_10-22'
'2018-10-22'.replace(/-/g, '_')  // '2018_10_22'
#+END_SRC

** uppercase first letter
#+BEGIN_SRC javascript
function capitalizeFirstLetter (string) {
  return string.charAt(0).toUpperCase() + string.slice(1)
}
#+END_SRC

* Array
** sort with lookuptable
#+BEGIN_SRC javascript
arr.sort((a, b) => lookuptable.indexOf(a) - lookuptable.indexOf(b))
#+END_SRC
** generate Array of numbers
#+BEGIN_SRC javascript
// with spread operator
[...Array(10).keys()]
// without spread operator
Array.from(Array(10).keys())
// 1 based
Array.from(Array(10), (e, i) => i + 1)
#nEND_SRC

** minimum / maximum
#+BEGIN_SRC javascript
// min
array.reduce((a, b) => Math.min(a, b))

// max
array.reduce((a, b) => Math.max(a, b))

#+END_SRC

** chunk
*** functional approach
#+BEGIN_SRC javascript
const chunkSize = 2 // items per chunk

const inputArray = ['a','b','c','d','e']

inputArray.reduce((resultArray, item, index) => {
  const chunkIndex = Math.floor(index/chunkSize)

  if(!resultArray[chunkIndex]) {
    resultArray[chunkIndex] = [] // start a new chunk
  }

  resultArray[chunkIndex].push(item)

  return resultArray
}, [])

// result: [['a','b'], ['c','d'], ['e']]
#+END_SRC

*** imperative approach
#+BEGIN_SRC javascript
function chunk (arr, chunksize) {
  const chunks = []
  for (let i = 0; i < arr.length; i += chunkSize) {
    chunks.push(arr.slice(i, i + chunkSize))
  }
  return chunks
}
#+END_SRC

** move element                                                  :immutable:
#+BEGIN_SRC javascript
function move (arr, oldIndex, requestedNewIndex) {
  const clone = arr.slice(0)
  const newIndex = (() => {
    if (requestedNewIndex >= clone.length) return clone.length + 1
    if (requestedNewIndex < 0) return 0
    return requestedNewIndex
  })()
  clone.splice(newIndex, 0, clone.splice(oldIndex, 1)[0])
  return clone
}
#+END_SRC

** transpose elements                                            :immutable:
#+BEGIN_SRC javascript
function transpose (arr, x, y) {
  const clone = arr.slice(0)
  const tmp = clone[x]
  clone[x] = clone[y]
  clone[y] = tmp
  return clone
}
#+END_SRC

** sort array of objects                                         :immutable:
#+BEGIN_SRC javascript
function sortByKey (arr, key) {
  const clone = JSON.parse(JSON.stringify(arr))
  return clone.sort((a, b) => {
    if (a[key] < b[key]) return -1
    if (a[key] > b[key]) return 1
    return 0
  })
}
#+END_SRC

** sort caseinsensitive
#+BEGIN_SRC javascript
arr.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
#+END_SRC

* Object
** get the value of nested object property by string key ('foo.bar')
#+BEGIN_SRC javascript
function getNestedProperty (obj, key) {
    return key.split('.').reduce(function(result, key) {
       return result[key]
    }, obj)
}
#+END_SRC

* date
*months are zerobased!*
** translate weekday
#+BEGIN_SRC javascript
moment().day('Montag').locale('en').format('dddd')
#+END_SRC
** all days of a timedelta
#+BEGIN_SRC javascript
function getDaysOfTimedelta (start, end) {
  let currentDay = moment(start).clone()
  const lastDay = moment(end).clone().add(1, 'days') // get the last day too
  const days = []
  while (!currentDay.isSame(lastDay, 'day')) {
    days.push(currentDay.format('YYYY-MM-DD'))
    currentDay.add(1, 'days')
  }
  return days
}
#+END_SRC
** all days of a month
#+BEGIN_SRC javascript
function getMonthDays (year = moment().year(), month = moment().month()) {
  const daysInMonth = moment({y: year, M: month, d: 1}).daysInMonth() // amount
  const monthDays = Array.from(Array(daysInMonth), (e, i) => i + 1) // eg [1, ..., 31]
  return monthDays.map(x => {
    return moment({y: year, M: month, d: x}).format('YYYY-MM-DD')
  })
},
#+END_SRC

** timedelta as objecct
#+BEGIN_SRC javascript
import moment from 'moment'

export function getTimedeltaObject (momentStart, momentEnd) {
  const diff = momentEnd.diff(momentStart)
  const duration = moment.duration(diff)
  return {
    m: duration.minutes(),
    h: duration.hours(),
    d: duration.days(),
    M: duration.months(),
    y: duration.years()
  }
}
#+END_SRC
* functional
** map
** reduce
*** nested reduce
#+BEGIN_SRC javascript
const v = state.appointments.mitarbeiter.reduce((acc, value) => {
  return acc + value.tage.reduce((accI, valueI) => {
    return accI + valueI.elemente.length
  }, 0)
}, 0)
#+END_SRC
** filter
** find
** stream
** functor
** monad
** lenses
** findIndex
*** remove duplicates (!unique) from array of objects
filter out elements on other index positions
#+BEGIN_SRC javascript
[{id: 1}, {id: 2}, {id: 2}].filter((x, index, self) =>
  index === self.findIndex(y => y.id === x.id)
)
#+END_SRC

* DOM
** find parent node / element by name
#+BEGIN_SRC javascript
function domGetParentTagByName (node, tagName) {
  let currentNode = node
  const tag = tagName.toUpperCase()
  while (true) {
    if (currentNode.tagName === tag) return currentNode
    if (currentNode.tagName === 'HTML') {
      console.error(`couldn't find parent ${tag}`)
      break
    }
    currentNode = currentNode.parentNode
  }
}
#+END_SRC
