* Equality comparisons and sameness
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness
https://dorey.github.io/JavaScript-Equality-Table/

if (what) { /* executes (yes || no) */ }

|-----------+----------|
| what      | executes |
|-----------+----------|
| true      | yes      |
| false     | no       |
| 1         | yes      |
| 0         | no       |
| -1        | yes      |
| "true"    | yes      |
| "false"   | yes      |
| "1"       | yes      |
| "0"       | yes      |
| "-1"      | yes      |
| ""        | no       |
| null      | no       |
| undefined | no       |
| Infinity  | yes      |
| -Infinity | yes      |
| []        | yes      |
| {}        | yes      |
| [[]]      | yes      |
| [0]       | yes      |
| [1]       | yes      |
| NaN       | no       |
|-----------+----------|

*Always use 3 equals unless you have a good reason to use 2.*

* Logging
** expandedLog
#+BEGIN_SRC javascript
function each (obj) {
  return toString.call(obj) === '[object ' + name + ']'
}
isObject = function (obj) {
  var type = typeof obj
  return type === 'function' || type === 'object' && !!obj
}
expandedLog = (function(){
    var MAX_DEPTH = 100;

    return function(item, depth){

        depth = depth || 0;

        if (depth > MAX_DEPTH ) {
            console.log(item);
            return;
        }

        if (isObject(item)) {
            each(item, function(value, key) {
            console.group(key + ' : ' +(typeof value));
            expandedLog(value, depth + 1);
            console.groupEnd();
            });
        } else {
            console.log(item);
        }
    }
})()
#+END_SRC

** objTree
like a directory listing in the shell

#+BEGIN_SRC javascript
function objTree (obj) {
  for (let k in obj) {
    if (typeof obj[k] == 'object' && obj[k] !== null) {
      console.group(k)
      objTree(obj[k])
      console.groupEnd(k)
    } else console.log(k)
  }
}
#+END_SRC

* format float
#+BEGIN_SRC javascript
function roundedToFixed (value, digits) {
  const power = Math.pow(10, digits || 0)
  return (Math.round(value * power) / power).toFixed(digits)
}
#+END_SRC

* Destructuring assignment
unpack values from arrays, or properties from objects, into distinct variables
Syntax is:
{incomingProperty: parameterName = defaultValue} = theObject

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

** array
#+BEGIN_SRC javascript
[a, b, ...rest] = [10, 20, 30, 40, 50]

console.log(a)
// expected output: 10
console.log(b)
// expected output: 20

console.log(rest)
// expected output: [30,40,50]
#+END_SRC

** skip values
#+BEGIN_SRC javascript
[a, , c] = [10, 20, 30]
#+END_SRC

** default values
#+BEGIN_SRC javascript
[a = 5, b = 7] = [1]
console.log(a) // 1
console.log(b) // 7
#+END_SRC

** swapping values
#+BEGIN_SRC javascript
let a = 1
let b = 3

[a, b] = [b, a]
console.log(a) // 3
console.log(b) // 1
#+END_SRC

** regex match
#+BEGIN_SRC javascript
function parseProtocol (url) {
  var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url)
  if (!parsedURL) {
    return false
  }
  console.log(parsedURL) // ["https://developer.mozilla.org/en-US/Web/JavaScript", "https", "developer.mozilla.org", "en-US/Web/JavaScript"]

  var [, protocol, fullhost, fullpath] = parsedURL
  return protocol
}
#+END_SRC

** object destruction

#+BEGIN_SRC javascript
const o = {p: 42, q: true}
const {p, q} = o

console.log(p) // 42
console.log(q) // true
#+END_SRC

** Assigning to new variables names and providing default values
#+BEGIN_SRC javascript
const {a: aa = 10, b: bb = 5} = {a: 3}

console.log(aa) // 3
console.log(bb) // 5
#+END_SRC

** Destructing nested objects
#+BEGIN_SRC javascript
const user = {
  id: 339,
  name: 'Fred',
  age: 42
};
const {education: {school: {name}} = {school: {name: 'Dunno'}}} = user;
console.log(name); //prints: Dunno
#+END_SRC

* remove umlaute
#+BEGIN_SRC javascript
// used for sort
export function removeUmlauts (str) {
  return str
    .replace(/Ä/g, 'A')
    .replace(/ä/g, 'a')
    .replace(/Ö/g, 'O')
    .replace(/ö/g, 'o')
    .replace(/Ü/g, 'U')
    .replace(/ü/g, 'u')
    .replace(/ß/g, 'ss')
}
#+END_SRC

* hash
#+BEGIN_SRC javascript
function hash (str) {
  let hash = 0
  let chr = 0
  let i = 0
  if (str.length === 0) return hash
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i)
    hash = ((hash << 5) - hash) + chr
    hash |= 0 // Convert to 32bit integer
  }
  return hash
}
#+END_SRC

* unique hex colors for strings
#+BEGIN_SRC javascript
// helper function to generate hexcolors for strings
stringToColour: function (str) {
  // employee color
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash)
  }
  let colour = '#'
  for (let i = 0; i < 3; i++) {
    let value = (hash >> (i * 8)) & 0xFF
    colour += ('00' + value.toString(16)).substr(-2)
  }
  return colour
}
#+END_SRC

* drag and drop
https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API
** Firefox: dragevents only fire when `initialized`
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC
** IE: DataTransfer.setData() format param has to be 'text'
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC

* limit function calls
** throttle
Throttling enforces a maximum number of times a function can be called
over time.
*Execute this function at most once every 100 milliseconds.*
#+BEGIN_SRC javascript
  function throttle (func, limit) {
    let lastFunc
    let lastRan
    return function () {
      const context = this
      const args = arguments
      if (!lastRan) {
        func.apply(context, args)
        lastRan = Date.now()
      } else {
        clearTimeout(lastFunc)
        lastFunc = setTimeout(function() {
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args)
            lastRan = Date.now()
          }
        }, limit - (Date.now() - lastRan))
      }
    }
  }
#+END_SRC

** debounce
Debouncing enforces that a function not be called again until a
certain amount of time has passed without it being called.
*execute this function only if 100 milliseconds have passed without it being called.*
#+BEGIN_SRC javascript
  function debounce (func, delay) {
    let inDebounce
    return function () {
      const context = this
      const args = arguments
      clearTimeout(inDebounce)
      inDebounce = setTimeout(() =>
          func.apply(context, args)
        , delay)
    }
  }
#+END_SRC

** use in Vue
#+BEGIN_SRC javascript
...
drag: throttle(function (event) {
  // code
}, 100),
...

#+END_SRC


* Immediately-Invoked Function Expression (IIFE)
Maintain Readability for Conditional Assignments with JavaScript IIFEs
You can use Immediately Invoked Function Expressions (IIFE's) to make
conditional assignments more readable and robust

#+BEGIN_SRC javascript
const greeting = (() => {
  if (isJoiningRoom) return 'Welcome'
  if (isLeavingRoom) return 'Bye'
  if (isReEnteringRoom) return 'Welcome back'
  return 'Hi'
})()
#+END_SRC

* String

** replcae
replaces only the first occurrence when invoked with two strings
#+BEGIN_SRC javascript
'2018-10-22'.replace('-', '_')  // '2018_10-22'
'2018-10-22'.replace(/-/g, '_')  // '2018_10_22'
#+END_SRC

** uppercase first letter
#+BEGIN_SRC javascript
function capitalizeFirstLetter (string) {
  return string.charAt(0).toUpperCase() + string.slice(1)
}
#+END_SRC

* Array
| Mutating  |                                     |
|-----------+-------------------------------------|
| push()    | Insert an element at the end        |
| pop()     | Remove an element from the end      |
| unshift() | Inserts an element in the beginning |
| shift()   | Remove first element                |

| Iterating |                                                     |
|-----------+-----------------------------------------------------|
| forEach() | Iterates an array                                   |
| filter()  | Iterates an array and result is filtered array      |
| map()     | Iterates an array and result is new array           |
| reduce()  | "Reduces" the array into single value (accumulator) |

| Others    |                                                     |
|-----------+-----------------------------------------------------|
| slice()   | Returns desired elements in a new array             |
| concat()  | Append one or more arrays with given array          |

** generate
*** range
#+BEGIN_SRC javascript
// Sequence generator function (commonly referred to as "range", e.g. Clojure, PHP etc)
const range = (start, stop, step) => Array.from({ length: (stop - start) / step }, (_, i) => start + (i * step));

// Generate numbers range 0..4
range(0, 5, 1);
// [0, 1, 2, 3, 4]
#+END_SRC
*** alphabet
#+BEGIN_SRC javascript
// Generate the alphabet using Array.from making use of it being ordered as a sequence
range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1, 1).map(x => String.fromCharCode(x));
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
#+END_SRC
*** times of day
#+BEGIN_SRC javascript
[...Array(24).keys()].map(h => {
  return ['00', '15', '30', '45'].map(m => `${h < 10 ? '0' : ''}${h}:${m}`)
}).flatMap(x => x)
// ["00:00", "00:15", "00:30", "00:45", "01:00", "01:15", "01:30", "01:45", "02:00", "02:15", "02:30", "02:45", "03:00", "03:15", "03:30", "03:45", "04:00", "04:15", "04:30", "04:45", "05:00", "05:15", "05:30", "05:45", "06:00", "06:15", "06:30", "06:45", "07:00", "07:15", "07:30", "07:45", "08:00", "08:15", "08:30", "08:45", "09:00", "09:15", "09:30", "09:45", "10:00", "10:15", "10:30", "10:45", "11:00", "11:15", "11:30", "11:45", "12:00", "12:15", "12:30", "12:45", "13:00", "13:15", "13:30", "13:45", "14:00", "14:15", "14:30", "14:45", "15:00", "15:15", "15:30", "15:45", "16:00", "16:15", "16:30", "16:45", "17:00", "17:15", "17:30", "17:45", "18:00", "18:15", "18:30", "18:45", "19:00", "19:15", "19:30", "19:45", "20:00", "20:15", "20:30", "20:45", "21:00", "21:15", "21:30", "21:45", "22:00", "22:15", "22:30", "22:45", "23:00", "23:15", "23:30", "23:45"]
#+END_SRC
** sort with lookuptable
#+BEGIN_SRC javascript
arr.sort((a, b) => lookuptable.indexOf(a) - lookuptable.indexOf(b))
#+END_SRC

** generate Array of numbers
#+BEGIN_SRC javascript
// with spread operator
[...Array(10).keys()]
// without spread operator
Array.from(Array(10).keys())
// 1 based
Array.from(Array(10), (e, i) => i + 1)
#nEND_SRC

** minimum / maximum
#+BEGIN_SRC javascript
// min
array.reduce((a, b) => Math.min(a, b))

// max
array.reduce((a, b) => Math.max(a, b))

#+END_SRC

** chunk
*** functional approach
#+BEGIN_SRC javascript
const chunkSize = 2 // items per chunk

const inputArray = ['a','b','c','d','e']

inputArray.reduce((resultArray, item, index) => {
  const chunkIndex = Math.floor(index/chunkSize)

  if(!resultArray[chunkIndex]) {
    resultArray[chunkIndex] = [] // start a new chunk
  }

  resultArray[chunkIndex].push(item)

  return resultArray
}, [])

// result: [['a','b'], ['c','d'], ['e']]
#+END_SRC

*** imperative approach
#+BEGIN_SRC javascript
function chunk (arr, chunksize) {
  const chunks = []
  for (let i = 0; i < arr.length; i += chunkSize) {
    chunks.push(arr.slice(i, i + chunkSize))
  }
  return chunks
}
#+END_SRC

** move element                                                  :immutable:
#+BEGIN_SRC javascript
function move (arr, oldIndex, requestedNewIndex) {
  const clone = arr.slice(0)
  const newIndex = (() => {
    if (requestedNewIndex >= clone.length) return clone.length + 1
    if (requestedNewIndex < 0) return 0
    return requestedNewIndex
  })()
  clone.splice(newIndex, 0, clone.splice(oldIndex, 1)[0])
  return clone
}
#+END_SRC

** transpose elements                                            :immutable:
#+BEGIN_SRC javascript
function transpose (arr, x, y) {
  const clone = arr.slice(0)
  const tmp = clone[x]
  clone[x] = clone[y]
  clone[y] = tmp
  return clone
}
#+END_SRC

** sort array of objects                                         :immutable:
#+BEGIN_SRC javascript
function sortByKey (arr, key) {
  const clone = JSON.parse(JSON.stringify(arr))
  return clone.sort((a, b) => {
    if (a[key] < b[key]) return -1
    if (a[key] > b[key]) return 1
    return 0
  })
}
#+END_SRC

** sort caseinsensitive
#+BEGIN_SRC javascript
arr.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
#+END_SRC

* Object
** merge
#+BEGIN_SRC javascript
const foo = {foo: 1}
const bar = {bar: 2}
const foobar = {...foo, ...bar}
#+END_SRC

** get the value of nested object property by string key ('foo.bar')
#+BEGIN_SRC javascript
function getNestedProperty (obj, key) {
    return key.split('.').reduce(function(result, key) {
       return result[key]
    }, obj)
}
#+END_SRC

* date
*months are zerobased!*
** translate weekday
#+BEGIN_SRC javascript
moment().day('Montag').locale('en').format('dddd')
#+END_SRC
** all days of a timedelta
#+BEGIN_SRC javascript
function getDaysOfTimedelta (start, end) {
  let currentDay = moment(start).clone()
  const lastDay = moment(end).clone().add(1, 'days') // get the last day too
  const days = []
  while (!currentDay.isSame(lastDay, 'day')) {
    days.push(currentDay.format('YYYY-MM-DD'))
    currentDay.add(1, 'days')
  }
  return days
}
#+END_SRC
** all days of a month
#+BEGIN_SRC javascript
function getMonthDays (year = moment().year(), month = moment().month()) {
  const daysInMonth = moment({y: year, M: month, d: 1}).daysInMonth() // amount
  const monthDays = Array.from(Array(daysInMonth), (e, i) => i + 1) // eg [1, ..., 31]
  return monthDays.map(x => {
    return moment({y: year, M: month, d: x}).format('YYYY-MM-DD')
  })
},
#+END_SRC

** timedelta as objecct
#+BEGIN_SRC javascript
import moment from 'moment'

export function getTimedeltaObject (momentStart, momentEnd) {
  const diff = momentEnd.diff(momentStart)
  const duration = moment.duration(diff)
  return {
    m: duration.minutes(),
    h: duration.hours(),
    d: duration.days(),
    M: duration.months(),
    y: duration.years()
  }
}
#+END_SRC
* functional
** map
** reduce
*** nested reduce
#+BEGIN_SRC javascript
const v = state.appointments.mitarbeiter.reduce((acc, value) => {
  return acc + value.tage.reduce((accI, valueI) => {
    return accI + valueI.elemente.length
  }, 0)
}, 0)
#+END_SRC
** filter
** find
** stream
** functor
** monad
** lenses
** findIndex
*** remove duplicates (!unique) from array of objects
filter out elements on other index positions
#+BEGIN_SRC javascript
[{id: 1}, {id: 2}, {id: 2}].filter((x, index, self) =>
  index === self.findIndex(y => y.id === x.id)
)
#+END_SRC

* DOM
** find parent node / element by name
#+BEGIN_SRC javascript
function domGetParentTagByName (node, tagName) {
  let currentNode = node
  const tag = tagName.toUpperCase()
  while (true) {
    if (currentNode.tagName === tag) return currentNode
    if (currentNode.tagName === 'HTML') {
      console.error(`couldn't find parent ${tag}`)
      break
    }
    currentNode = currentNode.parentNode
  }
}
#+END_SRC

* clone (depp copy) objects
https://smalldata.tech/blog/2018/11/01/copying-objects-in-javascript
#+BEGIN_SRC javascript
function deepClone (obj) {
  var copy;

  // Handle the 3 simple types, and null or undefined
  if (null == obj || "object" != typeof obj) return obj;

  // Handle Date
  if (obj instanceof Date) {
    copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  // Handle Array
  if (obj instanceof Array) {
    copy = [];
    for (var i = 0, len = obj.length; i < len; i++) {
        copy[i] = clone(obj[i]);
    }
    return copy;
  }

  // Handle Function
  if (obj instanceof Function) {
    copy = function() {
      return obj.apply(this, arguments);
    }
    return copy;
  }

  // Handle Object
  if (obj instanceof Object) {
      copy = {};
      for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
      }
      return copy;
  }

  throw new Error("Unable to copy obj as type isn't supported " + obj.constructor.name);
}
#+END_SRC

* parseInt() gotchas
#+BEGIN_SRC javascript
parseInt("10"); // Result: 10
parseInt("10.00"); // Result: 10
parseInt("10.33"); // Result: 10
parseInt("34 45 66"); // Result: 34
parseInt("   60   "); // Result: 60
parseInt("40 years"); // Result: 40
parseInt("He was 40"); // Result: NaN

parseInt("10", 10); // Result: 10
parseInt("010"); // Result: 8 - because it begins with 0
parseInt("010", 10); // Result: 10 - because base 10 is specified
                     // and that is more important than it
                     // beginning with a 0.
parseInt("10", 8); // Result: 8 - because base 8 is specified
parseInt("0x10"); // Result: 16 - because it begins with 0x
parseInt("10", 16); // Result: 16 - because base 16 is specified
#+END_SRC
