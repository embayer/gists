* limit function calls
** throttle
Throttling enforces a maximum number of times a function can be called
over time.
*Execute this function at most once every 100 milliseconds.*
#+BEGIN_SRC javascript
  function throttle (func, limit) {
    let lastFunc
    let lastRan
    return function () {
      const context = this
      const args = arguments
      if (!lastRan) {
        func.apply(context, args)
        lastRan = Date.now()
      } else {
        clearTimeout(lastFunc)
        lastFunc = setTimeout(function() {
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args)
            lastRan = Date.now()
          }
        }, limit - (Date.now() - lastRan))
      }
    }
  }
#+END_SRC

** debounce
Debouncing enforces that a function not be called again until a
certain amount of time has passed without it being called.
*execute this function only if 100 milliseconds have passed without it being called.*
#+BEGIN_SRC javascript
  function debounce (func, delay) {
    let inDebounce
    return function () {
      const context = this
      const args = arguments
      clearTimeout(inDebounce)
      inDebounce = setTimeout(() =>
          func.apply(context, args)
        , delay)
    }
  }
#+END_SRC

** use in Vue
#+BEGIN_SRC javascript
...
drag: throttle(function (event) {
  // code
}, 100),
...

#+END_SRC


* Immediately-Invoked Function Expression (IIFE)
Maintain Readability for Conditional Assignments with JavaScript IIFEs
You can use Immediately Invoked Function Expressions (IIFE's) to make
conditional assignments more readable and robust

#+BEGIN_SRC javascript
const greeting = (() => {
  if (isJoiningRoom) return 'Welcome'
  if (isLeavingRoom) return 'Bye'
  if (isReEnteringRoom) return 'Welcome back'
  return 'Hi'
})()
#+END_SRC

* String
** uppercase first letter
#+BEGIN_SRC javascript
function capitalizeFirstLetter (string) {
  return string.charAt(0).toUpperCase() + string.slice(1)
}
#+END_SRC

* Array
** chunk
*** functional approach
#+BEGIN_SRC javascript
const chunkSize = 2 // items per chunk

const inputArray = ['a','b','c','d','e']

inputArray.reduce((resultArray, item, index) => {
  const chunkIndex = Math.floor(index/chunkSize)

  if(!resultArray[chunkIndex]) {
    resultArray[chunkIndex] = [] // start a new chunk
  }

  resultArray[chunkIndex].push(item)

  return resultArray
}, [])

// result: [['a','b'], ['c','d'], ['e']]
#+END_SRC

*** imperative approach
#+BEGIN_SRC javascript
function chunk (arr, chunksize) {
  const chunks = []
  for (let i = 0; i < arr.length; i += chunkSize) {
    chunks.push(arr.slice(i, i + chunkSize))
  }
  return chunks
}
#+END_SRC

** move element                                                  :immutable:
#+BEGIN_SRC javascript
function move (arr, oldIndex, requestedNewIndex) {
  const clone = arr.slice(0)
  const newIndex = (() => {
    if (requestedNewIndex >= clone.length) return clone.length + 1
    if (requestedNewIndex < 0) return 0
    return requestedNewIndex
  })()
  clone.splice(newIndex, 0, clone.splice(oldIndex, 1)[0])
  return clone
}
#+END_SRC

** transpose elements                                            :immutable:
#+BEGIN_SRC javascript
function transpose (arr, x, y) {
  const clone = arr.slice(0)
  const tmp = clone[x]
  clone[x] = clone[y]
  clone[y] = tmp
  return clone
}
#+END_SRC

** sort array of objects                                         :immutable:
#+BEGIN_SRC javascript
function sortByKey (arr, key) {
  const clone = arr.slice(0)
  return clone.sort((a, b) => {
    if (a[key] < b[key]) return -1
    if (a[key] > b[key]) return 1
    return 0
  })
}
#+END_SRC

* date
** timedelta as objecct
#+BEGIN_SRC javascript
import moment from 'moment'

export function getTimedeltaObject (momentStart, momentEnd) {
  const diff = momentEnd.diff(momentStart)
  const duration = moment.duration(diff)
  return {
    m: duration.minutes(),
    h: duration.hours(),
    d: duration.days(),
    M: duration.months(),
    y: duration.years()
  }
}
#+END_SRC
* functional
** map
** reduce
*** nested reduce
#+BEGIN_SRC javascript
const v = state.appointments.mitarbeiter.reduce((acc, value) => {
  return acc + value.tage.reduce((accI, valueI) => {
    return accI + valueI.elemente.length
  }, 0)
}, 0)
#+END_SRC
** filter
** find
** stream
** functor
** monad
** lenses

* DOM
** find parent node / element by name
#+BEGIN_SRC javascript
function domGetParentTagByName (node, tagName) {
  let currentNode = node
  const tag = tagName.toUpperCase()
  while (true) {
    if (currentNode.tagName === tag) return currentNode
    if (currentNode.tagName === 'HTML') {
      console.error(`couldn't find parent ${tag}`)
      break
    }
    currentNode = currentNode.parentNode
  }
}
#+END_SRC
