* querySelector
https://www.w3schools.com/cssref/css_selectors.asp

| Selector                    | Example                                                     | Example description                                                                                  |
| .class                      | .intro                                                      | Selects all elements with class=intro"                                                               |
| .class1.class2              | <div class=name1 name2">...</div>"                          | "Selects all elements with both name1 and name2 set                                                  |
| within its class attribute" |                                                             |                                                                                                      |
| .class1 .class2             | <div class=name1">  <div class="name2">                     |                                                                                                      |
| ...  </div></div>"          | "Selects all elements with name2 that is a descendant of an |                                                                                                      |
| element with name1"         |                                                             |                                                                                                      |
| #id                         | #firstname                                                  | Selects the element with id=firstname"                                                               |
| *                           | *                                                           | Selects all elements                                                                                 |
| element                     | p                                                           | Selects all <p> elements                                                                             |
| element.class               | p.intro                                                     | Selects all <p> elements with class=intro"                                                           |
| element,element             | div, p                                                      | Selects all <div> elements and all <p> elements                                                      |
| element element             | div p                                                       | Selects all <p> elements inside <div> elements                                                       |
| element>element             | div > p                                                     | Selects all <p> elements where the parent is a <div> element                                         |
| element+element             | div + p                                                     | Selects all <p> elements that are placed immediately after <div> elements                            |
| element1~element2           | p ~ ul                                                      | Selects every <ul> element that are preceded by a <p> element                                        |
| [attribute]                 | [target]                                                    | Selects all elements with a target attribute                                                         |
| [attribute=value]           | [target=_blank]                                             | Selects all elements with target=_blank"                                                             |
| [attribute~=value]          | [title~=flower]                                             | Selects all elements with a title attribute containing the word flower"                              |
| [attribute\|=value]         | [lang\|=en]                                                 | Selects all elements with a lang attribute value starting with en"                                   |
| [attribute^=value]          | a[href^=https"]"                                            | Selects every <a> element whose href attribute value begins with https"                              |
| [attribute$=value]          | a[href$=.pdf"]"                                             | Selects every <a> element whose href attribute value ends with .pdf"                                 |
| [attribute*=value]          | a[href*=w3schools"]"                                        | Selects every <a> element whose href attribute value contains the substring w3schools"               |
| :active                     | a:active                                                    | Selects the active link                                                                              |
| ::after                     | p::after                                                    | Insert something after the content of each <p> element                                               |
| ::before                    | p::before                                                   | Insert something before the content of each <p> element                                              |
| :checked                    | input:checked                                               | Selects every checked <input> element                                                                |
| :default                    | input:default                                               | Selects the default <input> element                                                                  |
| :disabled                   | input:disabled                                              | Selects every disabled <input> element                                                               |
| :empty                      | p:empty                                                     | Selects every <p> element that has no children (including text nodes)                                |
| :enabled                    | input:enabled                                               | Selects every enabled <input> element                                                                |
| :first-child                | p:first-child                                               | Selects every <p> element that is the first child of its parent                                      |
| ::first-letter              | p::first-letter                                             | Selects the first letter of every <p> element                                                        |
| ::first-line                | p::first-line                                               | Selects the first line of every <p> element                                                          |
| :first-of-type              | p:first-of-type                                             | Selects every <p> element that is the first <p> element of its parent                                |
| :focus                      | input:focus                                                 | Selects the input element which has focus                                                            |
| :hover                      | a:hover                                                     | Selects links on mouse over                                                                          |
| :in-range                   | input:in-range                                              | Selects input elements with a value within a specified range                                         |
| :indeterminate              | input:indeterminate                                         | Selects input elements that are in an indeterminate state                                            |
| :invalid                    | input:invalid                                               | Selects all input elements with an invalid value                                                     |
| :lang(language)             | p:lang(it)                                                  | Selects every <p> element with a lang attribute equal to it" (Italian)"                              |
| :last-child                 | p:last-child                                                | Selects every <p> element that is the last child of its parent                                       |
| :last-of-type               | p:last-of-type                                              | Selects every <p> element that is the last <p> element of its parent                                 |
| :link                       | a:link                                                      | Selects all unvisited links                                                                          |
| :not(selector)              | :not(p)                                                     | Selects every element that is not a <p> element                                                      |
| :nth-child(n)               | p:nth-child(2)                                              | Selects every <p> element that is the second child of its parent                                     |
| :nth-last-child(n)          | p:nth-last-child(2)                                         | Selects every <p> element that is the second child of its parent, counting from the last child       |
| :nth-last-of-type(n)        | p:nth-last-of-type(2)                                       | Selects every <p> element that is the second <p> element of its parent, counting from the last child |
| :nth-of-type(n)             | p:nth-of-type(2)                                            | Selects every <p> element that is the second <p> element of its parent                               |
| :only-of-type               | p:only-of-type                                              | Selects every <p> element that is the only <p> element of its parent                                 |
| :only-child                 | p:only-child                                                | Selects every <p> element that is the only child of its parent                                       |
| :optional                   | input:optional                                              | Selects input elements with no required" attribute"                                                  |
| :out-of-range               | input:out-of-range                                          | Selects input elements with a value outside a specified range                                        |
| ::placeholder               | input::placeholder                                          | Selects input elements with placeholder text                                                         |
| :read-only                  | input:read-only                                             | Selects input elements with the readonly" attribute specified"                                       |
| :read-write                 | input:read-write                                            | Selects input elements with the readonly" attribute NOT specified"                                   |
| :required                   | input:required                                              | Selects input elements with the required" attribute specified"                                       |
| :root                       | :root                                                       | Selects the document's root element                                                                  |
| ::selection                 | ::selection                                                 | Selects the portion of an element that is selected by a user                                         |
| :target                     | #news:target                                                | Selects the current active #news element (clicked on a URL containing that anchor name)              |
| :valid                      | input:valid                                                 | Selects all input elements with a valid value                                                        |
| :visited                    | a:visited                                                   | Selects all visited links                                                                            |


|-----------+------------------------------------|
| query     | description                        |
|-----------+------------------------------------|
| .         | class                              |
| #         | id                                 |
| p         | <p> elements                       |
| div > p   | <p> elements with <div> parents    |
| div p     | <p> elements with <div> parents    |
| a[target] | <a> element with "target" attribut |
| p:not(.x) | <p> element not in class x         |
|-----------+------------------------------------|

* Equality comparisons and sameness
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness
https://dorey.github.io/JavaScript-Equality-Table/

if (what) { /* executes (yes || no) */ }

|-----------+----------|
| what      | executes |
|-----------+----------|
| true      | yes      |
| false     | no       |
| 1         | yes      |
| 0         | no       |
| -0        | no       |
| -1        | yes      |
| "true"    | yes      |
| "false"   | yes      |
| "1"       | yes      |
| "0"       | yes      |
| "-1"      | yes      |
| ""        | no       |
| null      | no       |
| undefined | no       |
| Infinity  | yes      |
| -Infinity | yes      |
| []        | yes      |
| {}        | yes      |
| [[]]      | yes      |
| [0]       | yes      |
| [1]       | yes      |
| NaN       | no       |
|-----------+----------|

*Always use 3 equals unless you have a good reason to use 2.*

* Logging
** expandedLog
#+BEGIN_SRC javascript
function each (obj) {
  return toString.call(obj) === '[object ' + name + ']'
}
isObject = function (obj) {
  var type = typeof obj
  return type === 'function' || type === 'object' && !!obj
}
expandedLog = (function(){
    var MAX_DEPTH = 100;

    return function(item, depth){

        depth = depth || 0;

        if (depth > MAX_DEPTH ) {
            console.log(item);
            return;
        }

        if (isObject(item)) {
            each(item, function(value, key) {
            console.group(key + ' : ' +(typeof value));
            expandedLog(value, depth + 1);
            console.groupEnd();
            });
        } else {
            console.log(item);
        }
    }
})()
#+END_SRC

** objTree
like a directory listing in the shell

#+BEGIN_SRC javascript
function objTree (obj) {
  for (let k in obj) {
    if (typeof obj[k] == 'object' && obj[k] !== null) {
      console.group(k)
      objTree(obj[k])
      console.groupEnd(k)
    } else console.log(k)
  }
}
#+END_SRC

* format float
#+BEGIN_SRC javascript
function roundedToFixed (value, digits) {
  const power = Math.pow(10, digits || 0)
  return (Math.round(value * power) / power).toFixed(digits)
}
#+END_SRC

* Destructuring assignment
unpack values from arrays, or properties from objects, into distinct variables
Syntax is:
{incomingProperty: parameterName = defaultValue} = theObject

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

** array
#+BEGIN_SRC javascript
[a, b, ...rest] = [10, 20, 30, 40, 50]

console.log(a)
// expected output: 10
console.log(b)
// expected output: 20

console.log(rest)
// expected output: [30,40,50]
#+END_SRC

** skip values
#+BEGIN_SRC javascript
[a, , c] = [10, 20, 30]
#+END_SRC

** default values
#+BEGIN_SRC javascript
[a = 5, b = 7] = [1]
console.log(a) // 1
console.log(b) // 7
#+END_SRC

** swapping values
#+BEGIN_SRC javascript
let a = 1
let b = 3

[a, b] = [b, a]
console.log(a) // 3
console.log(b) // 1
#+END_SRC

** regex match
#+BEGIN_SRC javascript
function parseProtocol (url) {
  var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url)
  if (!parsedURL) {
    return false
  }
  console.log(parsedURL) // ["https://developer.mozilla.org/en-US/Web/JavaScript", "https", "developer.mozilla.org", "en-US/Web/JavaScript"]

  var [, protocol, fullhost, fullpath] = parsedURL
  return protocol
}
#+END_SRC

** define object with optional property

#+BEGIN_SRC javascript
{...[1].length && {optionalProp: true}}
#+END_SRC

** object destruction

#+BEGIN_SRC javascript
const o = {p: 42, q: true}
const {p, q} = o

console.log(p) // 42
console.log(q) // true
#+END_SRC

** Assigning to new variables names and providing default values
#+BEGIN_SRC javascript
const {a: aa = 10, b: bb = 5} = {a: 3}

console.log(aa) // 3
console.log(bb) // 5
#+END_SRC

** Destructing nested objects
#+BEGIN_SRC javascript
const user = {
  id: 339,
  name: 'Fred',
  age: 42
};
const {education: {school: {name}} = {school: {name: 'Dunno'}}} = user;
console.log(name); //prints: Dunno
#+END_SRC

** Group by
#+BEGIN_SRC javascript
[...l].reduce(function(acc, x, _, arr) {
    /*
    Multiselect values are persisted as multiple different objects:
    [...
      {name: "answer_pk__863", value: "Vernier caliper", selector: "#id_answer_pk__863"},
      {name: "answer_pk__863", value: "Shore hardness gauge", selector: "#id_answer_pk__863"},
      {name: "answer_pk__863", value: "Measuring tape", selector: "#id_answer_pk__863"},
    ...]
    We group them here to get:
    [...
      {"name":"answer_pk__863","value":["Vernier caliper","Shore hardness gauge","Measuring tape"],"selector":"#id_answer_pk__863"},
    ...]
     */
    var count = arr.filter(y => y.name === x.name).length;
    if (count > 1) {
        // lookup if the last element of the accumulator isn't already the thing to group
        if (acc[acc.length - 1].name !== x.name) {
            x.value = arr.filter(y => y.name === x.name).map(y => y.value);
            acc.push(x);
        }
        // if so -> omit
    } else acc.push(x);
    return acc;
}, []);
#+END_SRC

* remove umlaute
#+BEGIN_SRC javascript
// used for sort
export function removeUmlauts (str) {
  return str
    .replace(/Ä/g, 'A')
    .replace(/ä/g, 'a')
    .replace(/Ö/g, 'O')
    .replace(/ö/g, 'o')
    .replace(/Ü/g, 'U')
    .replace(/ü/g, 'u')
    .replace(/ß/g, 'ss')
}
#+END_SRC

* hash

** simple hash for strings
#+BEGIN_SRC javascript
function hash (str) {
  let hash = 0
  let chr = 0
  let i = 0
  if (str.length === 0) return hash
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i)
    hash = ((hash << 5) - hash) + chr
    hash |= 0 // Convert to 32bit integer
  }
  return hash
}
#+END_SRC

** UUID
#+BEGIN_SRC javascript
// https://stackoverflow.com/a/2117523
function uuidv4 () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0
    const v = c === 'x' ? r : (r & 0x3 | 0x8)
    return v.toString(16)
  })
}
#+END_SRC

* unique hex colors for strings
#+BEGIN_SRC javascript
// helper function to generate hexcolors for strings
stringToColour: function (str) {
  // employee color
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash)
  }
  let colour = '#'
  for (let i = 0; i < 3; i++) {
    let value = (hash >> (i * 8)) & 0xFF
    colour += ('00' + value.toString(16)).substr(-2)
  }
  return colour
}
#+END_SRC

* drag and drop
https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API
** Firefox: dragevents only fire when `initialized`
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC
** IE: DataTransfer.setData() format param has to be 'text'
#+BEGIN_SRC javascript
event.dataTransfer.setData('text', this.id)
#+END_SRC

* limit function calls
** throttle
Throttling enforces a maximum number of times a function can be called
over time.
*Execute this function at most once every 100 milliseconds.*
#+BEGIN_SRC javascript
  function throttle (func, limit) {
    let lastFunc
    let lastRan
    return function () {
      const context = this
      const args = arguments
      if (!lastRan) {
        func.apply(context, args)
        lastRan = Date.now()
      } else {
        clearTimeout(lastFunc)
        lastFunc = setTimeout(function() {
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args)
            lastRan = Date.now()
          }
        }, limit - (Date.now() - lastRan))
      }
    }
  }
#+END_SRC

** debounce
Debouncing enforces that a function not be called again until a
certain amount of time has passed without it being called.
*execute this function only if 100 milliseconds have passed without it being called.*
#+BEGIN_SRC javascript
  function debounce (func, delay) {
    let inDebounce
    return function () {
      const context = this
      const args = arguments
      clearTimeout(inDebounce)
      inDebounce = setTimeout(() =>
          func.apply(context, args)
        , delay)
    }
  }
#+END_SRC

** use in Vue
#+BEGIN_SRC javascript
...
drag: throttle(function (event) {
  // code
}, 100),
...

#+END_SRC


* Immediately-Invoked Function Expression (IIFE)
Maintain Readability for Conditional Assignments with JavaScript IIFEs
You can use Immediately Invoked Function Expressions (IIFE's) to make
conditional assignments more readable and robust

#+BEGIN_SRC javascript
const greeting = (() => {
  if (isJoiningRoom) return 'Welcome'
  if (isLeavingRoom) return 'Bye'
  if (isReEnteringRoom) return 'Welcome back'
  return 'Hi'
})()
#+END_SRC

* String

** replcae
replaces only the first occurrence when invoked with two strings
#+BEGIN_SRC javascript
'2018-10-22'.replace('-', '_')  // '2018_10-22'
'2018-10-22'.replace(/-/g, '_')  // '2018_10_22'
#+END_SRC

** uppercase first letter
#+BEGIN_SRC javascript
function capitalizeFirstLetter (string) {
  return string.charAt(0).toUpperCase() + string.slice(1)
}
#+END_SRC

* Array

| Mutating   | These methods modify the array                                                                                       |
|------------+----------------------------------------------------------------------------------------------------------------------|
| push       | Insert an element at the end                                                                                         |
| pop        | Remove an element from the end                                                                                       |
| unshift    | Inserts an element in the beginning                                                                                  |
| shift      | Remove first element                                                                                                 |
| splice     | Adds and/or removes elements from an array                                                                           |
| sort       | Sorts the elements of an array in place and returns the array                                                        |
| reverse    | Reverses the order of the elements of an array in place — the first becomes the last, and the last becomes the first |
| fill       | Fills all the elements of an array from a start index to an end index with a static value                            |
| copyWithin | Copies a sequence of array elements within the array                                                                 |

| Iterating |                                                     |
|-----------+-----------------------------------------------------|
| forEach   | Iterates an array                                   |
| filter    | Iterates an array and result is filtered array      |
| map       | Iterates an array and result is new array           |
| reduce    | "Reduces" the array into single value (accumulator) |

| Others |                                            |
|--------+--------------------------------------------|
| slice  | Returns desired elements in a new array    |
| concat | Append one or more arrays with given array |

** compare
#+BEGIN_SRC javascript
function arraysEqual(a, b, respectOrder = true) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;

  if (respectOrder) {
    var cloneA = a;
    var cloneB = b;
  } else {
    var cloneA = a.sort();
    var cloneB = b.sort();
  }

  for (var i = 0; i < cloneA.length; ++i) {
    if (cloneA[i] !== cloneB[i]) return false;
  }
  return true;
}
#+END_SRC

** generate
*** range
#+BEGIN_SRC javascript
// Sequence generator function (commonly referred to as "range", e.g. Clojure, PHP etc)
const range = (start, stop, step) => Array.from({ length: (stop - start) / step }, (_, i) => start + (i * step));

// Generate numbers range 0..4
range(0, 5, 1);
// [0, 1, 2, 3, 4]
#+END_SRC

*** alphabet
#+BEGIN_SRC javascript
// Generate the alphabet using Array.from making use of it being ordered as a sequence
range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1, 1).map(x => String.fromCharCode(x));
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
#+END_SRC

*** quarters
#+BEGIN_SRC javascript
[...Array(24).keys()].map(h => {
  return ['00', '15', '30', '45'].map(m => `${h < 10 ? '0' : ''}${h}:${m}`)
}).flatMap(x => x)
// ["00:00", "00:15", "00:30", "00:45", "01:00", "01:15", "01:30", "01:45", "02:00", "02:15", "02:30", "02:45", "03:00", "03:15", "03:30", "03:45", "04:00", "04:15", "04:30", "04:45", "05:00", "05:15", "05:30", "05:45", "06:00", "06:15", "06:30", "06:45", "07:00", "07:15", "07:30", "07:45", "08:00", "08:15", "08:30", "08:45", "09:00", "09:15", "09:30", "09:45", "10:00", "10:15", "10:30", "10:45", "11:00", "11:15", "11:30", "11:45", "12:00", "12:15", "12:30", "12:45", "13:00", "13:15", "13:30", "13:45", "14:00", "14:15", "14:30", "14:45", "15:00", "15:15", "15:30", "15:45", "16:00", "16:15", "16:30", "16:45", "17:00", "17:15", "17:30", "17:45", "18:00", "18:15", "18:30", "18:45", "19:00", "19:15", "19:30", "19:45", "20:00", "20:15", "20:30", "20:45", "21:00", "21:15", "21:30", "21:45", "22:00", "22:15", "22:30", "22:45", "23:00", "23:15", "23:30", "23:45"]
#+END_SRC

explicit hours
#+BEGIN_SRC javascript
[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17].map(h => {
  return ['00', '15', '30', '45'].map(m => `${h < 10 ? '0' : ''}${h}:${m}`)
}).flatMap(x => x)
#+END_SRC

for start- and endtime
#+BEGIN_SRC javascript
const minMax = {min: '24:00', max: '00:00'}
const i = moment(minMax.min, 'HH:mm')
while (i.format('HH:mm') !== minMax.max) {
  state.quarters.push(i.format('HH:mm'))
  i.add(15, 'minutes') // change in place
}
#+END_SRC

** sort with lookuptable
#+BEGIN_SRC javascript
arr.sort((a, b) => lookuptable.indexOf(a) - lookuptable.indexOf(b))
#+END_SRC

** sort booleans
#+BEGIN_SRC javascript
const array = [true, false, true]
array.sort((a, b) => a - b)
// [false, true, true]
array.sort((a, b) => b - a)
// [true, true, false]
#+END_SRC

** map itempositions between 2 arrays
When the end is reached, start at the beginning

#+BEGIN_SRC javascript
const chars = ['a', 'b', 'c', 'd']
const numbers = [0, 1, 2]
function mapIt (str, a1, a2) {
  const idx = a1.indexOf(str)
  return a2[idx % a2.length]
}
mapIt('d', chars, numbers) // 0
#+END_SRC

** generate Array of numbers
#+BEGIN_SRC javascript
// with spread operator
[...Array(10).keys()]
// without spread operator
Array.from(Array(10).keys())
// 1 based
Array.from(Array(10), (e, i) => i + 1)
#nEND_SRC

** minimum / maximum
#+BEGIN_SRC javascript
// min
array.reduce((a, b) => Math.min(a, b))

// max
array.reduce((a, b) => Math.max(a, b))

#+END_SRC

** random slice
#+BEGIN_SRC javascript
function getRandomIntInclusive (min, max) {
  const randomBuffer = new Uint32Array(1)
  window.crypto.getRandomValues(randomBuffer)
  let randomNumber = randomBuffer[0] / (0xffffffff + 1)
  min = Math.ceil(min)
  max = Math.floor(max)
  return Math.floor(randomNumber * (max - min + 1)) + min
}
function getRandomSlice (array) {
  const arr = JSON.parse(JSON.stringify(array))
  const left = this.getRandomIntInclusive(0, arr.length)
  const right = this.getRandomIntInclusive(left, arr.length)
  return array.slice(left, right)
}
#+END_SRC

** zip merge
#+BEGIN_SRC javascript
      /* [a, b, c, d] => [a, c, b, d]
       * splits the given array in half
       * then merge the values back in alternating order: {left-half[0]}, {right-half[0], {left-half[1]}, {right-half[1]}...
       */
      zipmerge (array) {
        const array2 = JSON.parse(JSON.stringify(array))
        // slice in half
        const array1 = array2.splice(0, Math.ceil(array2.length / 2))
        // zipmerge (alternating)
        return array1.reduce((acc, x, idx) => {
          acc.push(x)
          if (array2.length > idx) acc.push(array2[idx])
          return acc
        }, [])
      },

#+END_SRC

** chunk
*** functional approach
#+BEGIN_SRC javascript
const chunkSize = 2 // items per chunk

const inputArray = ['a','b','c','d','e']

inputArray.reduce((resultArray, item, index) => {
  const chunkIndex = Math.floor(index/chunkSize)

  if(!resultArray[chunkIndex]) {
    resultArray[chunkIndex] = [] // start a new chunk
  }

  resultArray[chunkIndex].push(item)

  return resultArray
}, [])

// result: [['a','b'], ['c','d'], ['e']]
#+END_SRC

*** imperative approach
#+BEGIN_SRC javascript
function chunk (arr, chunksize) {
  const chunks = []
  for (let i = 0; i < arr.length; i += chunkSize) {
    chunks.push(arr.slice(i, i + chunkSize))
  }
  return chunks
}
#+END_SRC

** move element                                                  :immutable:
#+BEGIN_SRC javascript
function move (arr, oldIndex, requestedNewIndex) {
  const clone = arr.slice(0)
  const newIndex = (() => {
    if (requestedNewIndex >= clone.length) return clone.length + 1
    if (requestedNewIndex < 0) return 0
    return requestedNewIndex
  })()
  clone.splice(newIndex, 0, clone.splice(oldIndex, 1)[0])
  return clone
}
#+END_SRC

** transpose elements                                            :immutable:
#+BEGIN_SRC javascript
function transpose (arr, x, y) {
  const clone = arr.slice(0)
  const tmp = clone[x]
  clone[x] = clone[y]
  clone[y] = tmp
  return clone
}
#+END_SRC

** sort array of objects                                         :immutable:
#+BEGIN_SRC javascript
function sortByKey (arr, key) {
  const clone = JSON.parse(JSON.stringify(arr))
  return clone.sort((a, b) => {
    if (a[key] < b[key]) return -1
    if (a[key] > b[key]) return 1
    return 0
  })
}
#+END_SRC

** sort caseinsensitive
#+BEGIN_SRC javascript
arr.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
#+END_SRC

* Object
** function chaining
#+BEGIN_SRC javascript
var Kitten = function() {
  this.name = 'Garfield';
  this.color = 'brown';
  this.gender = 'male';
};

Kitten.prototype.setName = function(name) {
  this.name = name;
  return this;
};

Kitten.prototype.setColor = function(color) {
  this.color = color;
  return this;
};

Kitten.prototype.setGender = function(gender) {
  this.gender = gender;
  return this;
};

Kitten.prototype.save = function() {
  console.log(
    'saving ' + this.name + ', the ' +
    this.color + ' ' + this.gender + ' kitten...'
  );

  return this;
};
#+END_SRC

** merge
#+BEGIN_SRC javascript
const foo = {foo: 1}
const bar = {bar: 2}
const foobar = {...foo, ...bar}
#+END_SRC

** get the value of nested object property by string key ('foo.bar')
#+BEGIN_SRC javascript
function getNestedProperty (obj, key) {
    return key.split('.').reduce(function(result, key) {
       return result[key]
    }, obj)
}
#+END_SRC

** Test for existence of nested JavaScript object key
https://stackoverflow.com/questions/2631001/test-for-existence-of-nested-javascript-object-key
#+BEGIN_SRC javascript
function checkNested(obj, level,  ...rest) {
  if (obj === undefined) return false
  if (rest.length == 0 && obj.hasOwnProperty(level)) return true
  return checkNested(obj[level], ...rest)
}
#+END_SRC

** check if param is an object != array
#+BEGIN_SRC javascript
function isObject (supposedObject) {
  return (supposedObject === Object(supposedObject) && Object.prototype.toString.call(supposedObject) !== '[object Array]')
}
#+END_SRC

* date
*months are zerobased!*

** create date "without" time
#+BEGIN_SRC javascript
moment().startOf('day')
#+END_SRC

** localization
#+BEGIN_SRC javascript
import moment from 'moment'
import 'moment/locale/de'

moment.locale('de')
#+END_SRC

** start of week
#+BEGIN_SRC javascript
moment().startOf('isoWeek') // monday
moment().startOf('week') // sunday
#+END_SRC

** translate weekday
#+BEGIN_SRC javascript
moment().day('Montag').locale('en').format('dddd')
#+END_SRC

** all days of a timedelta
#+BEGIN_SRC javascript
function getDaysOfTimedelta (start, end) {
  let currentDay = moment(start).clone()
  const lastDay = moment(end).clone().add(1, 'days') // get the last day too
  const days = []
  while (!currentDay.isSame(lastDay, 'day')) {
    days.push(currentDay.format('YYYY-MM-DD'))
    currentDay.add(1, 'days')
  }
  return days
}
#+END_SRC

** all days of a month
#+BEGIN_SRC javascript
function getMonthDays (year = moment().year(), month = moment().month()) {
  const daysInMonth = moment({y: year, M: month, d: 1}).daysInMonth() // amount
  const monthDays = Array.from(Array(daysInMonth), (e, i) => i + 1) // eg [1, ..., 31]
  return monthDays.map(x => {
    return moment({y: year, M: month, d: x}).format('YYYY-MM-DD')
  })
},
#+END_SRC

** timedelta as objecct
#+BEGIN_SRC javascript
import moment from 'moment'

export function getTimedeltaObject (momentStart, momentEnd) {
  const diff = momentEnd.diff(momentStart)
  const duration = moment.duration(diff)
  return {
    m: duration.minutes(),
    h: duration.hours(),
    d: duration.days(),
    M: duration.months(),
    y: duration.years()
  }
}
#+END_SRC

** timedelta as string
#+BEGIN_SRC javascript
const aMoment = moment().subtract(7, 'days')
moment.duration(moment().diff(aMoment)).humanize() // 7 Tage
#+END_SRC

* functional
** map
** reduce
*** nested reduce
#+BEGIN_SRC javascript
const v = state.appointments.mitarbeiter.reduce((acc, value) => {
  return acc + value.tage.reduce((accI, valueI) => {
    return accI + valueI.elemente.length
  }, 0)
}, 0)
#+END_SRC
** filter
** find
** stream
** functor
** monad
** lenses
** findIndex
*** remove duplicates (!unique) from array of objects
filter out elements on other index positions
#+BEGIN_SRC javascript
[{id: 1}, {id: 2}, {id: 2}].filter((x, index, self) =>
  index === self.findIndex(y => y.id === x.id)
)
#+END_SRC

* DOM
** find parent node / element by name
#+BEGIN_SRC javascript
function domGetParentTagByName (node, tagName) {
  let currentNode = node
  const tag = tagName.toUpperCase()
  while (true) {
    if (currentNode.tagName === tag) return currentNode
    if (currentNode.tagName === 'HTML') {
      console.error(`couldn't find parent ${tag}`)
      break
    }
    currentNode = currentNode.parentNode
  }
}
#+END_SRC

** create nodes
https://stackoverflow.com/a/35385518
#+BEGIN_SRC javascript
/**
 * @param {String} HTML representing a single element
 * @return {Element}
 */
function htmlToElement(html) {
    var template = document.createElement('template');
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
}

var td = htmlToElement('<td>foo</td>'),
    div = htmlToElement('<div><span>nested</span> <span>stuff</span></div>');

/**
 * @param {String} HTML representing any number of sibling elements
 * @return {NodeList}
 */
function htmlToElements(html) {
    var template = document.createElement('template');
    template.innerHTML = html;
    return template.content.childNodes;
}

var rows = htmlToElements('<tr><td>foo</td></tr><tr><td>bar</td></tr>');
#+END_SRC

* clone (depp copy) objects
https://smalldata.tech/blog/2018/11/01/copying-objects-in-javascript
#+BEGIN_SRC javascript
function deepClone (obj) {
  var copy;

  // Handle the 3 simple types, and null or undefined
  if (null == obj || "object" != typeof obj) return obj;

  // Handle Date
  if (obj instanceof Date) {
    copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  // Handle Array
  if (obj instanceof Array) {
    copy = [];
    for (var i = 0, len = obj.length; i < len; i++) {
        copy[i] = clone(obj[i]);
    }
    return copy;
  }

  // Handle Function
  if (obj instanceof Function) {
    copy = function() {
      return obj.apply(this, arguments);
    }
    return copy;
  }

  // Handle Object
  if (obj instanceof Object) {
      copy = {};
      for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
      }
      return copy;
  }

  throw new Error("Unable to copy obj as type isn't supported " + obj.constructor.name);
}
#+END_SRC

* parseInt() gotchas
#+BEGIN_SRC javascript
parseInt("10"); // Result: 10
parseInt("10.00"); // Result: 10
parseInt("10.33"); // Result: 10
parseInt("34 45 66"); // Result: 34
parseInt("   60   "); // Result: 60
parseInt("40 years"); // Result: 40
parseInt("He was 40"); // Result: NaN

parseInt("10", 10); // Result: 10
parseInt("010"); // Result: 8 - because it begins with 0
parseInt("010", 10); // Result: 10 - because base 10 is specified
                     // and that is more important than it
                     // beginning with a 0.
parseInt("10", 8); // Result: 8 - because base 8 is specified
parseInt("0x10"); // Result: 16 - because it begins with 0x
parseInt("10", 16); // Result: 16 - because base 16 is specified
#+END_SRC

* localStorage
*Only stores strings*

** getter for other types

#+BEGIN_SRC javascript
/* extends localStorage
 * localStorage stores strings only
 * this prototype let's you get the real types
 * usage: localStorage.get('theKey')
 */
Storage.prototype.get = function(key) {
    return JSON.parse(this[key]);
}
#+END_SRC


** toggle booleans

#+BEGIN_SRC javascript
/* extends localStorage
 * toggle a boolean
 */
Storage.prototype.toggle = function(key) {
    var type = typeof JSON.parse(this[key])
    if (type !== 'boolean') {
        console.error('Storage.toggle only accepts Booleans');
        return;
    }
    var value = this.hasOwnProperty(key) ? !this.get(key) : true
    this.setItem(key, value)
}
#+END_SRC

* ServiceWorkers
** Cache on demand
#+BEGIN_SRC javascript
// init the on-demand-cache
self.addEventListener('install', function(event) {
    // install file needed offline
    event.waitUntil(
        caches.open('on-demand-cache')
            .then(function(cache) {
                console.log('Opened cache');
                return cache;
            })
    );
});

self.addEventListener('activate', function(event) {
    console.log('%c%s', 'border-radius: 0.2rem; padding: 0.2rem; color: white; background-color: CornflowerBlue; font-size: 16px', 'ServiceWorker activated');
    // prevents `service worker only works correct after pagereload` bug
    event.waitUntil(self.clients.claim());
});

// cache everything you fetch
self.addEventListener('fetch', function(event) {
    if (event.request.method !== 'GET') return;
    event.respondWith(
        caches.match(event.request)
            .then(function(response) {
                if (response) return response;
                var fetchRequest = event.request.clone();
                return fetch(fetchRequest).then(
                    function(response) {
                        // network with cache fallback
                        if (!response || response.status !== 200 || response.type !== 'basic') {
                            return response;
                        }
                        var responseToCache = response.clone();
                        caches.open('on-demand-cache')
                            .then(function(cache) {
                                cache.put(event.request, responseToCache);
                            });
                        return response;
                    }
                );
            })
    );
});
#+END_SRC

* constants
** daynames
#+BEGIN_SRC javascript
export const DAY_NAMES_EN = {
  'Montag': 'Monday',
  'Dienstag': 'Tuesday',
  'Mittwoch': 'Wednesday',
  'Donnerstag': 'Thursday',
  'Freitag': 'Friday',
  'Samstag': 'Saturday',
  'Sonntag': 'Sunday'
}
#+END_SRC

* functions

** rest parameter syntax
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters

#+BEGIN_SRC javascript
function f (x, ...args) {
  console.log(x, args, ...args, arguments)
}

f('a', 'b', 'c', z='d')

// Console Output:
// a
// Array(3) [ "b", "c", "d" ]
// b c d
// Arguments
// ​    0: "a"
//     ​1: "b"
//     ​2: "c"
//     ​3: "d"
//     ​length: 4
#+END_SRC

* Modal

** focustrap
https://hackernoon.com/its-a-focus-trap-699a04d66fb5
Prevent tabbing out of the modal by building a tab ring with the tabbable modal elements.

#+BEGIN_SRC javascript
// focustrap
const tabbableElements = document.querySelector('.modal-container').querySelectorAll('select, input, textarea, button, a')
const firstTabbableElement = tabbableElements[0]
const lastTabbableElement = tabbableElements[tabbableElements.length - 1]

if (tabbableElements.length === 0) return

// redirect first shift+tab to last input
firstTabbableElement.addEventListener('keydown', function (e) {
  if (e.which === 9 && e.shiftKey) {
    e.preventDefault()
    lastTabbableElement.focus()
  }
})
// redirect last tab to first input
lastTabbableElement.addEventListener('keydown', function (e) {
  if (e.which === 9 && !e.shiftKey) {
    e.preventDefault()
    firstTabbableElement.focus()
  }
})
#+END_SRC

* Cookies
** get
#+BEGIN_SRC javascript
// https://stackoverflow.com/a/15724300
function getCookie (name) {
  const value = '; ' + document.cookie
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}
#+END_SRC

** set
#+BEGIN_SRC javascript
function setCookie (name, value, exdays = 1) {
  const d = new Date()
  d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000))
  const expires = `expires=${d.toUTCString()}`
  document.cookie = `${name}=${value};${expires};path=/`
}
#+END_SRC
